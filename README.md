# compiCalc
A compiler course project implementing a calculator with a custom grammar, LL(1) parser, and three-address code generation.

# Compiler Course Project: Calculator Implementation

## Overview

This project is designed as part of the Compiler Design Principles course The project involves creating a lexical analyzer, a syntax analyzer (LL(1) parser), and generating three-address code. The generated code will be executed with the necessary action code added to the grammar.

## Grammar

The calculator will be implemented using the following grammar:

# Grammar Specification (Rules)

This document describes the grammar rules for the compiler project.

- **Stmts** → `Stmt ; Stmts`
- **Stmts** → `Stmt ;`
- **Stmt** → `print(id)`
- **Stmt** → `id = Expr`
- **Expr** → `Expr + Term`
- **Expr** → `Expr - Term`
- **Expr** → `Term`
- **Term** → `Term * Unary`
- **Term** → `Term / Unary`
- **Term** → `Unary`
- **Unary** → `- Unary`
- **Unary** → `Pow`
- **Pow** → `Factor ** Pow`
- **Pow** → `Factor`
- **Factor** → `(Expr)`
- **Factor** → `id`
- **Factor** → `sin(Expr)`
- **Factor** → `cos(Expr)`
- **Factor** → `num`


## Components

1. **Lexical Analyzer:** Analyzes the input and generates tokens.
2. **Syntax Analyzer (LL(1) Parser):** Parses the tokens based on the provided grammar.
3. **Three-Address Code Generator:** Generates the three-address code and executes it.

## Additional Rules and Details

1. A new rule has been added to the end of the grammar.
2. `id` represents an identifier token that starts with an English letter and continues with letters, digits, or underscores.
3. `num` represents a numeric token, which can be an integer, decimal, or scientific notation.
4. `**` is the power operator.
5. `print` takes an identifier as input and prints its value.
6. Input is read from a file named `input.txt`.
7. The generated three-address code is saved in a file named `output.txt`.

### Sample Input

Place the following sample input in a file named `input.txt`:

- `x = 12;`
- `new_x = x ** 2;`
- `y = 2 * x + new_x * sin(x);`
- `print(x);`
- `print(y);`

### Expected Output (Three-Address Code)

The following three-address code will be saved in `output.txt`:

- `(= , #12 , , t1)`
- `(= , t1 , , x)`
- `(** , x , #2 , t2)`
- `(= , t2 , , new_x)`
- `(* , #2 , x , t3)`
- `(sin , x , , t4)`
- `(* , new_x , t4 , t5)`
- `( + , t3 , t5 , t6)`
- `(= , t6 , , y)`
- `(p , x , , )`
- `(p , y , , )`



Running the code will produce the following output:

12

-53.2665

## Modules Overview

The project consists of several Python modules designed to implement a simple programming language interpreter. Here’s an overview of each module:

### lexer.py
- **Description:** This module defines a lexer that breaks down input code into tokens (smallest units such as numbers, identifiers, operators, etc.).
- **Functionality:** Utilizes regular expressions (`re`) to match and identify tokens based on predefined patterns.
- **Token Types:** Includes tokens such as `NUM` (numbers), `ID` (identifiers), `PLUS`, `MINUS`, `TIMES`, `DIVIDE` (operators), `PRINT`, `ASSIGN` (keywords), and `WS` (whitespace).
- **Error Handling:** Manages errors like unexpected characters or syntax issues.

### parser.py
- **Description:** The parser module uses the tokens generated by the lexer to parse syntactic structures according to a defined grammar.
- **Technique:** Employs a recursive descent parsing technique.
- **Functionality:** Verifies and interprets statements such as assignments (`ID = expr;`) and print statements (`print(ID);`).
- **Error Handling:** Catches errors such as missing semicolons or unexpected tokens during parsing.

### codegen.py
- **Description:** Implements a code generator that translates parsed statements into an intermediate code format.
- **Functionality:** Handles assignments and print statements.
- **Operations:** Intermediate code operations include assignment (`=`), arithmetic operations (`+`, `-`, `*`, `/`, `**`), and function calls (`sin`, `cos`).

### evaluator.py
- **Description:** The evaluator module interprets and executes the intermediate code generated by the code generator.
- **Functionality:** Maintains a symbol table to store variable values during execution.
- **Method:** The `evaluate` method reads input from a file, executes assignments, evaluates expressions, and handles print statements.

### main.py
- **Description:** Serves as the entry point, orchestrating the interaction between lexer, parser, code generator, and evaluator.
- **Functionality:** Reads input code, invokes the lexer and parser to generate a parse tree, uses the code generator to produce intermediate code, and finally, the evaluator to execute and produce results.

